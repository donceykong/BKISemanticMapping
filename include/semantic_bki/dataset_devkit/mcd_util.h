#pragma once

#include <fstream>
#include <sstream>
#include <vector>
#include <set>
#include <string>
#include <memory>
#include <thread>
#include <chrono>
#include <cstdlib>
#include <cstdint>
#include <cstdio>

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <tf2_eigen/tf2_eigen.hpp>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include <Eigen/Dense>
#include <Eigen/Geometry>
#include <yaml-cpp/yaml.h>

#include <pcl/common/transforms.h>
#include <pcl/io/pcd_io.h>
#include <pcl_conversions/pcl_conversions.h>

#include "bkioctomap.h"
#include "markerarray_pub.h"
#include "osm_geometry.h"

class MCDData {
  public:
    MCDData(rclcpp::Node::SharedPtr node,
             double resolution, double block_depth,
             double sf2, double ell,
             int num_class, double free_thresh,
             double occupied_thresh, float var_thresh, 
             double ds_resolution,
             double free_resolution, double max_range,
             std::string map_topic,
             float prior)
      : node_(node)
      , resolution_(resolution)
      , ds_resolution_(ds_resolution)
      , free_resolution_(free_resolution)
      , max_range_(max_range)
      , tf_broadcaster_(node)
      , tf_buffer_(std::make_shared<tf2_ros::Buffer>(node->get_clock()))
      , tf_listener_(*tf_buffer_) {
        if (!node_) {
          RCLCPP_WARN_STREAM(rclcpp::get_logger("mcd_util"), "WARNING: MCDData constructor: node_ is null!");
        }
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: MCDData constructor: Creating octomap");
        map_ = new semantic_bki::SemanticBKIOctoMap(resolution, block_depth, num_class, sf2, ell, prior, var_thresh, free_thresh, occupied_thresh);
        if (!map_) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Failed to create SemanticBKIOctoMap!");
        } else {
          RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Octomap created successfully");
        }
        
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Creating MarkerArrayPub");
        m_pub_ = new semantic_bki::MarkerArrayPub(node_, map_topic, resolution);
        if (!m_pub_) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Failed to create MarkerArrayPub!");
        } else {
          RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: MarkerArrayPub created successfully");
        }
        
        // Publisher for individual scan point clouds
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Creating pointcloud publisher");
        pointcloud_pub_ = node_->create_publisher<sensor_msgs::msg::PointCloud2>("/mcd_scan_pointcloud", 10);
        if (!pointcloud_pub_) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Failed to create pointcloud publisher!");
        } else {
          RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Pointcloud publisher created successfully");
        }
        
        // Identity transformation for MCD (poses are already in world frame)
        init_trans_to_ground_ = Eigen::Matrix4d::Identity();
        // Body to LiDAR transformation (must be loaded from calibration - no default identity)
        // Will be set by load_calibration_from_params() - if not set, will error
        body_to_lidar_tf_ = Eigen::Matrix4d::Zero();  // Set to zero to detect if not loaded
        original_first_pose_ = Eigen::Matrix4d::Identity();  // Will be set when poses are loaded
        scan_indices_.clear();  // Initialize scan indices vector
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: MCDData constructor completed");
      }

    bool read_lidar_poses(const std::string lidar_pose_name) {
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: read_lidar_poses: Opening file: " << lidar_pose_name);
      std::ifstream fPoses;
      fPoses.open(lidar_pose_name.c_str());
      if (!fPoses.is_open()) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Cannot open pose file " << lidar_pose_name);
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Cannot open pose file " << lidar_pose_name);
        return false;
      }
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Pose file opened successfully");
      
      // Skip header line if present
      std::string header_line;
      std::getline(fPoses, header_line);
      
      // Check if header contains column names (common in CSV)
      bool has_header = (header_line.find("num") != std::string::npos || 
                         header_line.find("timestamp") != std::string::npos ||
                         header_line.find("x") != std::string::npos);
      
      if (!has_header) {
        // No header, rewind to beginning
        fPoses.close();
        fPoses.open(lidar_pose_name.c_str());
      }

      while (!fPoses.eof()) {
        std::string s;
        std::getline(fPoses, s);
        
        // Skip empty lines and comments
        if (s.empty() || s[0] == '#') {
          continue;
        }

        std::stringstream ss(s);
        std::string token;
        std::vector<double> values;
        
        // Parse CSV line (handles comma-separated or space-separated)
        char delimiter = ',';
        if (s.find(',') == std::string::npos) {
          delimiter = ' ';
        }
        
        while (std::getline(ss, token, delimiter)) {
          try {
            double val = std::stod(token);
            values.push_back(val);
          } catch (...) {
            // Skip invalid tokens
            continue;
          }
        }

        // Expect at least 8 values: num, timestamp, x, y, z, qx, qy, qz, qw
        // Or 9 values if first is index
        if (values.size() < 8) {
          continue;
        }

        // Extract scan index (num) - first column in CSV
        int scan_index = (int)values[0];
        
        // Extract pose values (skip num and timestamp, they're at indices 0 and 1)
        double x = values[2];
        double y = values[3];
        double z = values[4];
        double qx = values[5];
        double qy = values[6];
        double qz = values[7];
        double qw = values.size() > 8 ? values[8] : 1.0;  // Default qw to 1.0 if not provided

        // Convert quaternion to rotation matrix
        Eigen::Quaterniond quat(qw, qx, qy, qz);
        quat.normalize();
        
        // Build transformation matrix
        Eigen::Matrix4d t_matrix = Eigen::Matrix4d::Identity();
        t_matrix.block<3, 3>(0, 0) = quat.toRotationMatrix();
        t_matrix(0, 3) = x;
        t_matrix(1, 3) = y;
        t_matrix(2, 3) = z;
        
        lidar_poses_.push_back(t_matrix);
        scan_indices_.push_back(scan_index);
      }
      
      fPoses.close();
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Finished reading pose file, loaded " << lidar_poses_.size() << " poses");
      
      if (lidar_poses_.empty()) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: No poses loaded from " << lidar_pose_name);
        RCLCPP_ERROR_STREAM(node_->get_logger(), "No poses loaded from " << lidar_pose_name);
        return false;
      }
      
      // Store original first pose before transformation (needed for OSM data alignment)
      original_first_pose_ = lidar_poses_[0];
      
      // Make all poses relative to the first pose (set first pose to origin)
      // This means: transform all poses by the inverse of the first pose
      Eigen::Matrix4d first_pose_inverse = lidar_poses_[0].inverse();
      
      RCLCPP_INFO_STREAM(node_->get_logger(), "First pose before alignment:");
      RCLCPP_INFO_STREAM(node_->get_logger(), "  Translation: [" << lidar_poses_[0](0,3) << ", " << lidar_poses_[0](1,3) << ", " << lidar_poses_[0](2,3) << "]");
      
      // Transform all poses to be relative to the first pose
      for (size_t i = 0; i < lidar_poses_.size(); ++i) {
        lidar_poses_[i] = first_pose_inverse * lidar_poses_[i];
      }
      
      // Verify first pose is now at origin
      RCLCPP_INFO_STREAM(node_->get_logger(), "After alignment - First pose should be identity:");
      RCLCPP_INFO_STREAM(node_->get_logger(), "  Translation: [" << lidar_poses_[0](0,3) << ", " << lidar_poses_[0](1,3) << ", " << lidar_poses_[0](2,3) << "]");
      RCLCPP_INFO_STREAM(node_->get_logger(), "Loaded " << lidar_poses_.size() << " poses from " << lidar_pose_name << " (all relative to first pose)");
      
      return true;
    }
    
    // Get the original first pose (before transformation to origin)
    // This is needed to align OSM data with the same coordinate frame
    Eigen::Matrix4d getOriginalFirstPose() const {
      return original_first_pose_;
    }

    /// Set map visualization color mode: semantic class or OSM prior (building/road/grassland/tree).
    void set_color_mode(semantic_bki::MapColorMode mode) {
      if (m_pub_) m_pub_->set_color_mode(mode);
    }

    void set_osm_buildings(const std::vector<semantic_bki::Geometry2D> &buildings) {
      if (map_) map_->set_osm_buildings(buildings);
    }
    void set_osm_roads(const std::vector<semantic_bki::Geometry2D> &roads) {
      if (map_) map_->set_osm_roads(roads);
    }
    void set_osm_grasslands(const std::vector<semantic_bki::Geometry2D> &grasslands) {
      if (map_) map_->set_osm_grasslands(grasslands);
    }
    void set_osm_trees(const std::vector<semantic_bki::Geometry2D> &trees) {
      if (map_) map_->set_osm_trees(trees);
    }
    void set_osm_tree_points(const std::vector<std::pair<float, float>> &tree_points) {
      if (map_) map_->set_osm_tree_points(tree_points);
    }
    void set_osm_decay_meters(float decay_m) {
      if (map_) map_->set_osm_decay_meters(decay_m);
    }

    /// Return true if both the lidar bin and label file exist for the given scan file number.
    bool scan_and_label_exist(const std::string& input_data_dir, const std::string& input_label_dir, int scan_file_num) {
      char scan_id_c[256];
      std::snprintf(scan_id_c, sizeof(scan_id_c), "%010d", scan_file_num);
      std::string scan_name = input_data_dir + "/" + std::string(scan_id_c) + ".bin";
      std::string label_name = input_label_dir + "/" + std::string(scan_id_c) + ".bin";
      FILE* fp = std::fopen(scan_name.c_str(), "rb");
      if (!fp) return false;
      std::fclose(fp);
      FILE* fp_label = std::fopen(label_name.c_str(), "rb");
      if (!fp_label) return false;
      std::fclose(fp_label);
      return true;
    }

    bool process_scans(std::string input_data_dir, std::string input_label_dir, int scan_num, int skip_frames, bool query, bool visualize) {
      if (!map_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: process_scans: map_ is null!");
        return false;
      }
      if (!m_pub_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: process_scans: m_pub_ is null!");
        return false;
      }
      if (lidar_poses_.empty()) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: process_scans: No poses loaded!");
        return false;
      }
      
      // Build list of pose indices where both lidar bin and label file exist (matching file names)
      std::vector<int> valid_pose_indices;
      valid_pose_indices.reserve(lidar_poses_.size());
      for (int pose_idx = 0; pose_idx < static_cast<int>(lidar_poses_.size()); ++pose_idx) {
        int scan_file_num = scan_indices_[pose_idx];
        if (scan_and_label_exist(input_data_dir, input_label_dir, scan_file_num))
          valid_pose_indices.push_back(pose_idx);
      }
      RCLCPP_INFO_STREAM(node_->get_logger(), "Found " << valid_pose_indices.size() << " scans with both lidar and label files (out of " << lidar_poses_.size() << " poses). Applying scan_num=" << scan_num << ", skip_frames=" << skip_frames);
      
      // Apply scan_num and skip_frames to the valid set: take every (skip_frames+1)-th valid scan, up to scan_num
      int valid_count = 0;
      std::vector<int> indices_to_process;
      for (size_t i = 0; i < valid_pose_indices.size(); ++i) {
        if (skip_frames > 0 && valid_count % (skip_frames + 1) != 0) {
          valid_count++;
          continue;
        }
        if (static_cast<int>(indices_to_process.size()) >= scan_num)
          break;
        indices_to_process.push_back(valid_pose_indices[i]);
        valid_count++;
      }
      
      semantic_bki::point3f origin;
      int insertion_count = 0;
      
      for (size_t list_idx = 0; list_idx < indices_to_process.size(); ++list_idx) {
        int pose_idx = indices_to_process[list_idx];
        int scan_file_num = scan_indices_[pose_idx];
        
        char scan_id_c[256];
        sprintf(scan_id_c, "%010d", scan_file_num);
        std::string scan_name = input_data_dir + "/" + std::string(scan_id_c) + ".bin";
        std::string label_name = input_label_dir + "/" + std::string(scan_id_c) + ".bin";
        
        pcl::PointCloud<pcl::PointXYZL>::Ptr cloud = mcd2pcl(scan_name, label_name);
        if (!cloud) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: mcd2pcl returned null pointer for scan " << scan_file_num);
          continue;
        }
        if (cloud->points.empty()) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Empty point cloud at scan file " << scan_file_num << " (pose index " << pose_idx << "), skipping");
          continue;
        }
  
        Eigen::Matrix4d transform = lidar_poses_[pose_idx];  // This is body_to_world from pose
        
        // Verify body-to-lidar transform is loaded (should not be zero matrix)
        if (body_to_lidar_tf_.isZero(1e-10)) {
          RCLCPP_FATAL_STREAM(node_->get_logger(), "ERROR: body_to_lidar_tf_ is not initialized! Calibration must be loaded before processing scans.");
          RCLCPP_FATAL_STREAM(node_->get_logger(), "Call load_calibration_from_params() and ensure it returns true.");
          exit(1);
        }
        
        // Apply body-to-lidar transformation
        // The poses in CSV are body/IMU poses, need to transform from lidar frame to world frame
        // Following Python code: transform_matrix = body_to_world @ lidar_to_body
        // where lidar_to_body = inv(body_to_lidar_tf)
        Eigen::Matrix4d lidar_to_body = body_to_lidar_tf_.inverse();
        Eigen::Matrix4d lidar_to_map = transform * lidar_to_body;  // T_lidar_to_map = body_to_world * lidar_to_body
        
        // Publish TF transform from 'map' to 'lidar' frame
        geometry_msgs::msg::TransformStamped t;
        t.header.stamp = node_->now();
        t.header.frame_id = "map";
        t.child_frame_id = "lidar";
        
        Eigen::Matrix3d rotation = lidar_to_map.block<3, 3>(0, 0);
        Eigen::Vector3d translation = lidar_to_map.block<3, 1>(0, 3);
        
        Eigen::Quaterniond quat(rotation);
        t.transform.translation.x = translation(0);
        t.transform.translation.y = translation(1);
        t.transform.translation.z = translation(2);
        t.transform.rotation.x = quat.x();
        t.transform.rotation.y = quat.y();
        t.transform.rotation.z = quat.z();
        t.transform.rotation.w = quat.w();
        
        tf_broadcaster_.sendTransform(t);
        
        // Debug: Print transform info for first few processed scans
        if (list_idx < 3) {
          RCLCPP_INFO_STREAM(node_->get_logger(), "Scan " << list_idx << " (pose_idx " << pose_idx << ") Transform info:");
          RCLCPP_INFO_STREAM(node_->get_logger(), "  Body-to-world translation from CSV: [" << transform(0,3) << ", " << transform(1,3) << ", " << transform(2,3) << "]");
          RCLCPP_INFO_STREAM(node_->get_logger(), "  Lidar-to-map translation: [" << lidar_to_map(0,3) << ", " << lidar_to_map(1,3) << ", " << lidar_to_map(2,3) << "]");
          RCLCPP_INFO_STREAM(node_->get_logger(), "  TF translation (from lidar_to_map): [" << translation(0) << ", " << translation(1) << ", " << translation(2) << "]");
          
          // Verify: transform origin from lidar frame should give lidar_to_map translation
          Eigen::Vector4d lidar_origin(0, 0, 0, 1);
          Eigen::Vector4d map_origin_test = lidar_to_map * lidar_origin;
          RCLCPP_INFO_STREAM(node_->get_logger(), "  Verification - lidar origin in map coords: [" << map_origin_test(0) << ", " << map_origin_test(1) << ", " << map_origin_test(2) << "]");
        }
        
        // Publish individual scan as PointCloud2 (in lidar frame, before transformation)
        sensor_msgs::msg::PointCloud2 cloud_msg;
        pcl::toROSMsg(*cloud, cloud_msg);
        cloud_msg.header.frame_id = "lidar";
        cloud_msg.header.stamp = node_->now();
        pointcloud_pub_->publish(cloud_msg);
        
        if (insertion_count == 0) {
          RCLCPP_INFO_STREAM(node_->get_logger(), "Published PointCloud2 with " << cloud->points.size() << " points in frame 'lidar'");
        }
        
        // Now transform cloud to world frame for map insertion
        pcl::transformPointCloud(*cloud, *cloud, lidar_to_map);
        
        origin.x() = transform(0, 3);
        origin.y() = transform(1, 3);
        origin.z() = transform(2, 3);
        
        try {
          map_->insert_pointcloud(*cloud, origin, ds_resolution_, free_resolution_, max_range_);
        } catch (const std::exception& e) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Exception during insert_pointcloud: " << e.what());
          continue;
        }
        insertion_count++;
        
        // Skip query/visualize for first insertion to avoid potential segfaults with empty/initializing octree
        if (insertion_count == 1) {
          RCLCPP_DEBUG_STREAM(node_->get_logger(), "Skipping query/visualize for first insertion");
          continue;
        }
        
        if (query) {
          // Query previous scans (use pose indices, not file numbers)
          // Original ROS1 logic: for (int query_pose_idx = pose_idx - 10; query_pose_idx >= 0 && query_pose_idx <= pose_idx; ++query_pose_idx)
          for (int query_pose_idx = pose_idx - 10; query_pose_idx >= 0 && query_pose_idx <= pose_idx; ++query_pose_idx) {
            query_scan(input_data_dir, input_label_dir, query_pose_idx);
          }
        }

        if (visualize) {
          publish_map();
          // Small delay to allow rviz to process the visualization
          std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
      }
      
      // Final publish after all scans are processed
      if (visualize) {
        RCLCPP_INFO_STREAM(node_->get_logger(), "All scans processed. Publishing final map visualization...");
        publish_map();
      }
      
      return true;
    }

    void publish_map() {
      if (!m_pub_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: publish_map: m_pub_ is null!");
        return;
      }
      if (!map_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: publish_map: map_ is null!");
        return;
      }

      m_pub_->clear_map(resolution_);
      
      // Check if map is empty before iterating - get iterators separately to catch segfault location
      try {
        auto begin_it = map_->begin_leaf();
        
        auto end_it = map_->end_leaf();
        
        if (begin_it == end_it) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Map is empty (begin == end), nothing to publish");
          m_pub_->publish();
          return;
        }
      } catch (const std::exception& e) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Exception getting iterators: " << e.what());
        return;
      } catch (...) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Unknown exception getting iterators");
        return;
      }
      
      semantic_bki::MapColorMode mode = m_pub_->get_color_mode();
      int voxel_count = 0;
      int iter_count = 0;
      try {
        auto loop_begin = map_->begin_leaf();
        auto loop_end = map_->end_leaf();
        
        auto it = loop_begin;
        
        while (it != loop_end) {
          iter_count++;
          
          try {
            auto node = it.get_node();
            
              if (node.get_state() == semantic_bki::State::OCCUPIED) {
              semantic_bki::point3f p = it.get_loc();
              float size = it.get_size();
              if (mode == semantic_bki::MapColorMode::Semantic) {
                m_pub_->insert_point3d_semantics(p.x(), p.y(), p.z(), size, node.get_semantics(), 2);
              } else if (mode == semantic_bki::MapColorMode::OSMBlend) {
                m_pub_->insert_point3d_osm_blend(p.x(), p.y(), p.z(), size,
                    node.get_osm_building(), node.get_osm_road(), node.get_osm_grassland(), node.get_osm_tree());
              } else {
                int prior_type = 0;
                float value = 0.f;
                switch (mode) {
                  case semantic_bki::MapColorMode::OSMBuilding:   prior_type = 0; value = node.get_osm_building(); break;
                  case semantic_bki::MapColorMode::OSMRoad:      prior_type = 1; value = node.get_osm_road(); break;
                  case semantic_bki::MapColorMode::OSMGrassland:  prior_type = 2; value = node.get_osm_grassland(); break;
                  case semantic_bki::MapColorMode::OSMTree:     prior_type = 3; value = node.get_osm_tree(); break;
                  default: prior_type = 0; value = node.get_osm_building(); break;
                }
                m_pub_->insert_point3d_osm_prior(p.x(), p.y(), p.z(), size, value, prior_type);
              }
              voxel_count++;
            }
            
            if (iter_count % 1000 == 0) {
              RCLCPP_DEBUG_STREAM(node_->get_logger(), "Processed " << iter_count << " nodes");
            }
            
            // Increment iterator
            ++it;
          } catch (const std::exception& e) {
            RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Exception at iteration " << iter_count << ": " << e.what());
            break;
          } catch (...) {
            RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Unknown exception at iteration " << iter_count);
            break;
          }
        }
      } catch (const std::exception& e) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Exception during map iteration: " << e.what());
        return;
      }
      m_pub_->publish();
    }
    
    // Load colors from ROS parameters
    bool load_colors_from_params() {
      if (m_pub_) {
        return m_pub_->load_colors_from_params(node_);
      }
      return false;
    }
    
    // Load colors directly from YAML file
    bool load_colors_from_yaml(const std::string& yaml_file_path) {
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: MCDData::load_colors_from_yaml: Starting, file=" << yaml_file_path);
      if (!m_pub_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: m_pub_ is null, cannot load colors!");
        return false;
      }
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: m_pub_ is valid, calling load_colors_from_yaml");
      bool result = m_pub_->load_colors_from_yaml(yaml_file_path);
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: MCDData::load_colors_from_yaml: Result=" << result);
      return result;
    }

    void set_up_evaluation(const std::string gt_label_dir, const std::string evaluation_result_dir) {
      gt_label_dir_ = gt_label_dir;
      evaluation_result_dir_ = evaluation_result_dir;
    }

    bool load_calibration_from_params() {
      // Load body-to-lidar transform from ROS parameters
      // Expected path: body/os_sensor/T (from hhs_calib.yaml)
      // Format: T is a list of 4 lists, each containing 4 doubles
      
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: load_calibration_from_params: Starting");
      try {
        // First, try to load from calibration_file parameter (YAML file path)
        std::string calib_file;
        if (node_->get_parameter("calibration_file", calib_file)) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Found calibration_file parameter: " << calib_file);
          RCLCPP_INFO_STREAM(node_->get_logger(), "Loading calibration from YAML file: " << calib_file);
          bool result = load_calibration_from_yaml(calib_file);
          RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: load_calibration_from_yaml returned: " << result);
          return result;
        }
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: calibration_file parameter not found");
        
        // Fallback: try to get body parameter directly from ROS parameters
        if (node_->has_parameter("body")) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "Calibration loading from ROS parameters not fully implemented. Please use calibration_file parameter.");
          return false;
        }
        
        RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: 'calibration_file' parameter not found in ROS parameter server!");
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Make sure calibration_file parameter is set in the launch file pointing to hhs_calib.yaml.");
        return false;
      } catch (const std::exception& e) {
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Error loading calibration: " << e.what());
        return false;
      }
    }
    
    bool load_calibration_from_yaml(const std::string& yaml_file) {
      RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: load_calibration_from_yaml: Loading file: " << yaml_file);
      try {
        YAML::Node yaml_node = YAML::LoadFile(yaml_file);
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: YAML file loaded successfully");
        if (!yaml_node["body"]) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: 'body' key not found in YAML file!");
          RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: 'body' key not found in YAML file!");
          return false;
        }
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Found 'body' key in YAML");
        
        YAML::Node body_node = yaml_node["body"];
        if (!body_node["os_sensor"]) {
          RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: 'body/os_sensor' not found in calibration!");
          return false;
        }
        
        YAML::Node os_sensor_node = body_node["os_sensor"];
        if (!os_sensor_node["T"]) {
          RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: 'body/os_sensor/T' not found in calibration!");
          return false;
        }
        
        YAML::Node T_node = os_sensor_node["T"];
        if (!T_node.IsSequence() || T_node.size() != 4) {
          RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: 'body/os_sensor/T' must be an array of 4 arrays!");
          return false;
        }
        
        // Parse the 4x4 matrix
        for (int i = 0; i < 4; ++i) {
          if (!T_node[i].IsSequence() || T_node[i].size() != 4) {
            RCLCPP_ERROR_STREAM(node_->get_logger(), "ERROR: Row " << i << " of body/os_sensor/T must be an array of 4 elements!");
            return false;
          }
          for (int j = 0; j < 4; ++j) {
            body_to_lidar_tf_(i, j) = T_node[i][j].as<double>();
          }
        }
        
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: Successfully parsed calibration transform matrix");
        RCLCPP_INFO_STREAM(node_->get_logger(), "Successfully loaded body-to-lidar transform from body/os_sensor/T");
        RCLCPP_INFO_STREAM(node_->get_logger(), "Transform matrix:");
        RCLCPP_INFO_STREAM(node_->get_logger(), "  [" << body_to_lidar_tf_(0, 0) << ", " << body_to_lidar_tf_(0, 1) << ", " << body_to_lidar_tf_(0, 2) << ", " << body_to_lidar_tf_(0, 3) << "]");
        RCLCPP_INFO_STREAM(node_->get_logger(), "  [" << body_to_lidar_tf_(1, 0) << ", " << body_to_lidar_tf_(1, 1) << ", " << body_to_lidar_tf_(1, 2) << ", " << body_to_lidar_tf_(1, 3) << "]");
        RCLCPP_INFO_STREAM(node_->get_logger(), "  [" << body_to_lidar_tf_(2, 0) << ", " << body_to_lidar_tf_(2, 1) << ", " << body_to_lidar_tf_(2, 2) << ", " << body_to_lidar_tf_(2, 3) << "]");
        RCLCPP_INFO_STREAM(node_->get_logger(), "  [" << body_to_lidar_tf_(3, 0) << ", " << body_to_lidar_tf_(3, 1) << ", " << body_to_lidar_tf_(3, 2) << ", " << body_to_lidar_tf_(3, 3) << "]");
        
        RCLCPP_WARN_STREAM(node_->get_logger(), "CHECKPOINT: load_calibration_from_yaml completed successfully");
        return true;
      } catch (const std::exception& e) {
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Error loading calibration from YAML: " << e.what());
        return false;
      }
    }

    void query_scan(std::string input_data_dir, std::string /* input_label_dir */, int pose_idx) {
      if (pose_idx < 0 || pose_idx >= (int)lidar_poses_.size()) {
        return;
      }
      
      if (!map_) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "Cannot query scan: map_ is null");
        return;
      }

      try {
        // Get the actual scan file number from CSV
        int scan_file_num = scan_indices_[pose_idx];
        
        // Use 10-digit format for MCD file naming
        char scan_id_c[256];
        sprintf(scan_id_c, "%010d", scan_file_num);
        // Helper function to join paths (handles trailing slashes)
        auto join_path = [](const std::string& dir, const std::string& file) -> std::string {
          if (dir.empty()) return file;
          if (dir.back() == '/') return dir + file;
          return dir + "/" + file;
        };
        std::string scan_name = join_path(input_data_dir, std::string(scan_id_c) + ".bin");
        std::string gt_name = join_path(gt_label_dir_, std::string(scan_id_c) + ".bin");
        std::string result_name = join_path(evaluation_result_dir_, std::string(scan_id_c) + ".txt");
        
        pcl::PointCloud<pcl::PointXYZL>::Ptr cloud = mcd2pcl(scan_name, gt_name);
        if (cloud->points.empty()) {
          return;
        }

        Eigen::Matrix4d transform = lidar_poses_[pose_idx];  // This is body_to_world from pose
        
        // Apply body-to-lidar transformation (same as in process_scans)
        // Following Python code: transform_matrix = body_to_world @ lidar_to_body
        Eigen::Matrix4d lidar_to_body = body_to_lidar_tf_.inverse();
        Eigen::Matrix4d new_transform = transform * lidar_to_body;  // body_to_world * lidar_to_body
        pcl::transformPointCloud(*cloud, *cloud, new_transform);

        // Create directory if it doesn't exist
        size_t last_slash = result_name.find_last_of('/');
        if (last_slash != std::string::npos) {
          std::string dir_path = result_name.substr(0, last_slash);
          // Try to create directory (mkdir -p equivalent)
          std::string mkdir_cmd = "mkdir -p " + dir_path;
          int result = std::system(mkdir_cmd.c_str());
          if (result != 0) {
            RCLCPP_WARN_STREAM(node_->get_logger(), "Failed to create directory: " << dir_path);
          }
        }
        
        std::ofstream result_file;
        result_file.open(result_name);
        if (!result_file.is_open()) {
          RCLCPP_WARN_STREAM(node_->get_logger(), "Cannot open result file: " << result_name);
          return;
        }
        
        for (int i = 0; i < (int)cloud->points.size(); ++i) {
          try {
            semantic_bki::SemanticOcTreeNode node = map_->search(cloud->points[i].x, cloud->points[i].y, cloud->points[i].z);
            int pred_label = 0;
            if (node.get_state() == semantic_bki::State::OCCUPIED)
              pred_label = node.get_semantics();
            result_file << (int)cloud->points[i].label << " " << pred_label << "\n";
          } catch (const std::exception& e) {
            RCLCPP_WARN_STREAM(node_->get_logger(), "Exception searching map for point " << i << ": " << e.what());
            continue;
          }
        }
        result_file.close();
      } catch (const std::exception& e) {
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Exception in query_scan(): " << e.what());
      } catch (...) {
        RCLCPP_ERROR_STREAM(node_->get_logger(), "Unknown exception in query_scan()");
      }
    }

  
  private:
    rclcpp::Node::SharedPtr node_;
    double resolution_;
    double ds_resolution_;
    double free_resolution_;
    double max_range_;
    semantic_bki::SemanticBKIOctoMap* map_;
    semantic_bki::MarkerArrayPub* m_pub_;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pointcloud_pub_;  // Publisher for individual scan point clouds
    tf2_ros::TransformBroadcaster tf_broadcaster_;
    std::shared_ptr<tf2_ros::Buffer> tf_buffer_;
    tf2_ros::TransformListener tf_listener_;
    std::ofstream pose_file_;
    std::vector<Eigen::Matrix4d> lidar_poses_;
    std::vector<int> scan_indices_;  // Maps pose index to actual scan file number (from CSV "num" column)
    std::string gt_label_dir_;
    std::string evaluation_result_dir_;
    Eigen::Matrix4d init_trans_to_ground_;
    Eigen::Matrix4d body_to_lidar_tf_;  // Body to LiDAR transformation from calibration
    Eigen::Matrix4d original_first_pose_;  // Original first pose before transformation to origin (for OSM alignment)

    pcl::PointCloud<pcl::PointXYZL>::Ptr mcd2pcl(std::string fn, std::string fn_label) {
      // Open scan file
      FILE* fp = std::fopen(fn.c_str(), "rb");
      if (!fp) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Cannot open scan file: " << fn);
        return pcl::PointCloud<pcl::PointXYZL>::Ptr(new pcl::PointCloud<pcl::PointXYZL>);
      }

      // Open label file
      FILE* fp_label = std::fopen(fn_label.c_str(), "rb");
      if (!fp_label) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Cannot open label file: " << fn_label);
        std::fclose(fp);
        return pcl::PointCloud<pcl::PointXYZL>::Ptr(new pcl::PointCloud<pcl::PointXYZL>);
      }

      // Get file size for scan (x, y, z, intensity = 4 floats per point)
      std::fseek(fp, 0L, SEEK_END);
      size_t sz = std::ftell(fp);
      std::rewind(fp);
      int n_hits = static_cast<int>(sz / (sizeof(float) * 4));

      // Get label file size (expected: n_hits * sizeof(uint32_t) per label)
      std::fseek(fp_label, 0L, SEEK_END);
      long label_file_sz = std::ftell(fp_label);
      std::rewind(fp_label);
      int num_labels_in_file = static_cast<int>(label_file_sz / sizeof(uint32_t));
      RCLCPP_INFO_STREAM(node_->get_logger(), "\n\n\n\n     Scan: " << fn << " \n\nlabel file: " << fn_label << " number of labels: " << num_labels_in_file << "\n\n\n\n");

      // Preallocate point cloud for better performance (avoids reallocation)
      pcl::PointCloud<pcl::PointXYZL>::Ptr pc(new pcl::PointCloud<pcl::PointXYZL>);
      if (!pc) {
        RCLCPP_WARN_STREAM(node_->get_logger(), "WARNING: Failed to allocate point cloud!");
        std::fclose(fp);
        std::fclose(fp_label);
        return pcl::PointCloud<pcl::PointXYZL>::Ptr(new pcl::PointCloud<pcl::PointXYZL>);
      }
      pc->points.reserve(n_hits);  // Preallocate to avoid reallocation overhead
      pc->width = n_hits;
      pc->height = 1;
      pc->is_dense = false;

      // Read data in a tighter loop; collect unique class IDs for logging
      int points_read = 0;
      std::set<int> unique_labels;
      for (int i = 0; i < n_hits; i++) {
        pcl::PointXYZL point;
        float intensity;
        uint32_t label;

        // Read point data (x, y, z, intensity as floats)
        if (fread(&point.x, sizeof(float), 1, fp) != 1) break;
        if (fread(&point.y, sizeof(float), 1, fp) != 1) break;
        if (fread(&point.z, sizeof(float), 1, fp) != 1) break;
        if (fread(&intensity, sizeof(float), 1, fp) != 1) break;

        // Read label (uint32)
        if (fread(&label, sizeof(uint32_t), 1, fp_label) != 1) break;

        point.label = static_cast<int>(label);
        unique_labels.insert(point.label);
        pc->points.push_back(point);
        points_read++;
      }
      
      std::fclose(fp);
      std::fclose(fp_label);
      
      // // Print list of unique class IDs in this label file (should match Python inspect_label_file.py)
      // std::ostringstream oss;
      // oss << "Unique classes in label file (" << fn_label << "): ";
      // for (auto it = unique_labels.begin(); it != unique_labels.end(); ++it) {
      //   if (it != unique_labels.begin()) oss << ", ";
      //   oss << *it;
      // }
      // RCLCPP_INFO_STREAM(node_->get_logger(), oss.str());
      // // Sanity: first few label values (compare with Python inspect_label_file.py)
      // if (points_read >= 5) {
      //   std::ostringstream dbg;
      //   dbg << "First 5 label values (uint32): " << pc->points[0].label << ", " << pc->points[1].label << ", " << pc->points[2].label << ", " << pc->points[3].label << ", " << pc->points[4].label;
      //   RCLCPP_INFO_STREAM(node_->get_logger(), dbg.str());
      // }
      
      // // RED error if label count does not match point count
      // if (points_read != n_hits || num_labels_in_file != n_hits) {
      //   RCLCPP_ERROR_STREAM(node_->get_logger(),
      //     "ERROR: Label count does not match point count! scan=" << fn
      //     << " label_file=" << fn_label
      //     << " points_in_scan=" << n_hits
      //     << " labels_in_file=" << num_labels_in_file
      //     << " points_read=" << points_read);
      // }
      
      return pc;
    }
};
